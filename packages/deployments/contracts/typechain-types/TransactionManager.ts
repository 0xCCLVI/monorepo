/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";

export declare namespace TransactionManager {
  export type CallParamsStruct = {
    recipient: string;
    callTo: string;
    callData: BytesLike;
    originDomain: BigNumberish;
    destinationDomain: BigNumberish;
  };

  export type CallParamsStructOutput = [string, string, string, number, number] & {
    recipient: string;
    callTo: string;
    callData: string;
    originDomain: number;
    destinationDomain: number;
  };

  export type FulfillArgsStruct = {
    params: TransactionManager.CallParamsStruct;
    local: string;
    router: string;
    feePercentage: BigNumberish;
    amount: BigNumberish;
    index: BigNumberish;
    transactionId: BytesLike;
    proof: BytesLike[];
    relayerSignature: BytesLike;
  };

  export type FulfillArgsStructOutput = [
    TransactionManager.CallParamsStructOutput,
    string,
    string,
    number,
    BigNumber,
    BigNumber,
    string,
    string[],
    string,
  ] & {
    params: TransactionManager.CallParamsStructOutput;
    local: string;
    router: string;
    feePercentage: number;
    amount: BigNumber;
    index: BigNumber;
    transactionId: string;
    proof: string[];
    relayerSignature: string;
  };

  export type PrepareArgsStruct = {
    params: TransactionManager.CallParamsStruct;
    transactingAssetId: string;
    amount: BigNumberish;
  };

  export type PrepareArgsStructOutput = [TransactionManager.CallParamsStructOutput, string, BigNumber] & {
    params: TransactionManager.CallParamsStructOutput;
    transactingAssetId: string;
    amount: BigNumber;
  };
}

export declare namespace BridgeMessage {
  export type TokenIdStruct = { domain: BigNumberish; id: BytesLike };

  export type TokenIdStructOutput = [number, string] & {
    domain: number;
    id: string;
  };
}

export interface TransactionManagerInterface extends utils.Interface {
  contractName: "TransactionManager";
  functions: {
    "acceptProposedOwner()": FunctionFragment;
    "addLiquidity(uint256,address)": FunctionFragment;
    "addLiquidityFor(uint256,address,address)": FunctionFragment;
    "addRelayerFees(address)": FunctionFragment;
    "addRouter(address)": FunctionFragment;
    "addStableSwapPool((uint32,bytes32),address)": FunctionFragment;
    "adoptedToCanonical(address)": FunctionFragment;
    "adoptedToLocalPools(bytes32)": FunctionFragment;
    "approvedAssets(bytes32)": FunctionFragment;
    "approvedRouters(address)": FunctionFragment;
    "assetOwnershipTimestamp()": FunctionFragment;
    "batchAmounts(uint32,uint256)": FunctionFragment;
    "batchAssets(uint32,uint256)": FunctionFragment;
    "bridgeRouter()": FunctionFragment;
    "canonicalToAdopted(bytes32)": FunctionFragment;
    "count()": FunctionFragment;
    "delay()": FunctionFragment;
    "dispatch(uint32)": FunctionFragment;
    "domain()": FunctionFragment;
    "fulfill(((address,address,bytes,uint32,uint32),address,address,uint32,uint256,uint256,bytes))": FunctionFragment;
    "initialize(uint256,address,address,address)": FunctionFragment;
    "interpreter()": FunctionFragment;
    "isAssetOwnershipRenounced()": FunctionFragment;
    "isRouterOwnershipRenounced()": FunctionFragment;
    "nonce()": FunctionFragment;
    "owner()": FunctionFragment;
    "prepare(((address,address,bytes,uint32,uint32),address,uint256))": FunctionFragment;
    "process(bytes32,uint256,address,uint256,bytes32[32],(address,address,bytes,uint32,uint32))": FunctionFragment;
    "proposeAssetOwnershipRenunciation()": FunctionFragment;
    "proposeNewOwner(address)": FunctionFragment;
    "proposeRouterOwnershipRenunciation()": FunctionFragment;
    "proposed()": FunctionFragment;
    "proposedTimestamp()": FunctionFragment;
    "reconcile(bytes32)": FunctionFragment;
    "removeAssetId(bytes32,address)": FunctionFragment;
    "removeLiquidity(uint256,address,address)": FunctionFragment;
    "removeRelayerFees(uint256,address)": FunctionFragment;
    "removeRouter(address)": FunctionFragment;
    "renounceAssetOwnership()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "renounceRouterOwnership()": FunctionFragment;
    "renounced()": FunctionFragment;
    "root()": FunctionFragment;
    "routedTransactions(bytes32)": FunctionFragment;
    "routedTransactionsGas(bytes32)": FunctionFragment;
    "routerBalances(address,address)": FunctionFragment;
    "routerOwnershipTimestamp()": FunctionFragment;
    "routerRelayerFees(address)": FunctionFragment;
    "setupAsset((uint32,bytes32),address,address)": FunctionFragment;
    "tokenRegistry()": FunctionFragment;
    "tree()": FunctionFragment;
    "wrapper()": FunctionFragment;
  };

  encodeFunctionData(functionFragment: "acceptProposedOwner", values?: undefined): string;
  encodeFunctionData(functionFragment: "addLiquidity", values: [BigNumberish, string]): string;
  encodeFunctionData(functionFragment: "addLiquidityFor", values: [BigNumberish, string, string]): string;
  encodeFunctionData(functionFragment: "addRelayerFees", values: [string]): string;
  encodeFunctionData(functionFragment: "addRouter", values: [string]): string;
  encodeFunctionData(functionFragment: "addStableSwapPool", values: [BridgeMessage.TokenIdStruct, string]): string;
  encodeFunctionData(functionFragment: "adoptedToCanonical", values: [string]): string;
  encodeFunctionData(functionFragment: "adoptedToLocalPools", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "approvedAssets", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "approvedRouters", values: [string]): string;
  encodeFunctionData(functionFragment: "assetOwnershipTimestamp", values?: undefined): string;
  encodeFunctionData(functionFragment: "batchAmounts", values: [BigNumberish, BigNumberish]): string;
  encodeFunctionData(functionFragment: "batchAssets", values: [BigNumberish, BigNumberish]): string;
  encodeFunctionData(functionFragment: "bridgeRouter", values?: undefined): string;
  encodeFunctionData(functionFragment: "canonicalToAdopted", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "count", values?: undefined): string;
  encodeFunctionData(functionFragment: "delay", values?: undefined): string;
  encodeFunctionData(functionFragment: "dispatch", values: [BigNumberish]): string;
  encodeFunctionData(functionFragment: "domain", values?: undefined): string;
  encodeFunctionData(functionFragment: "fulfill", values: [TransactionManager.FulfillArgsStruct]): string;
  encodeFunctionData(functionFragment: "initialize", values: [BigNumberish, string, string, string]): string;
  encodeFunctionData(functionFragment: "interpreter", values?: undefined): string;
  encodeFunctionData(functionFragment: "isAssetOwnershipRenounced", values?: undefined): string;
  encodeFunctionData(functionFragment: "isRouterOwnershipRenounced", values?: undefined): string;
  encodeFunctionData(functionFragment: "nonce", values?: undefined): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "prepare", values: [TransactionManager.PrepareArgsStruct]): string;
  encodeFunctionData(
    functionFragment: "process",
    values: [BytesLike, BigNumberish, string, BigNumberish, BytesLike[], TransactionManager.CallParamsStruct],
  ): string;
  encodeFunctionData(functionFragment: "proposeAssetOwnershipRenunciation", values?: undefined): string;
  encodeFunctionData(functionFragment: "proposeNewOwner", values: [string]): string;
  encodeFunctionData(functionFragment: "proposeRouterOwnershipRenunciation", values?: undefined): string;
  encodeFunctionData(functionFragment: "proposed", values?: undefined): string;
  encodeFunctionData(functionFragment: "proposedTimestamp", values?: undefined): string;
  encodeFunctionData(functionFragment: "reconcile", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "removeAssetId", values: [BytesLike, string]): string;
  encodeFunctionData(functionFragment: "removeLiquidity", values: [BigNumberish, string, string]): string;
  encodeFunctionData(functionFragment: "removeRelayerFees", values: [BigNumberish, string]): string;
  encodeFunctionData(functionFragment: "removeRouter", values: [string]): string;
  encodeFunctionData(functionFragment: "renounceAssetOwnership", values?: undefined): string;
  encodeFunctionData(functionFragment: "renounceOwnership", values?: undefined): string;
  encodeFunctionData(functionFragment: "renounceRouterOwnership", values?: undefined): string;
  encodeFunctionData(functionFragment: "renounced", values?: undefined): string;
  encodeFunctionData(functionFragment: "root", values?: undefined): string;
  encodeFunctionData(functionFragment: "routedTransactions", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "routedTransactionsGas", values: [BytesLike]): string;
  encodeFunctionData(functionFragment: "routerBalances", values: [string, string]): string;
  encodeFunctionData(functionFragment: "routerOwnershipTimestamp", values?: undefined): string;
  encodeFunctionData(functionFragment: "routerRelayerFees", values: [string]): string;
  encodeFunctionData(functionFragment: "setupAsset", values: [BridgeMessage.TokenIdStruct, string, string]): string;
  encodeFunctionData(functionFragment: "tokenRegistry", values?: undefined): string;
  encodeFunctionData(functionFragment: "tree", values?: undefined): string;
  encodeFunctionData(functionFragment: "wrapper", values?: undefined): string;

  decodeFunctionResult(functionFragment: "acceptProposedOwner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "addLiquidity", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "addLiquidityFor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "addRelayerFees", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "addRouter", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "addStableSwapPool", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "adoptedToCanonical", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "adoptedToLocalPools", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approvedAssets", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "approvedRouters", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "assetOwnershipTimestamp", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "batchAmounts", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "batchAssets", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "bridgeRouter", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "canonicalToAdopted", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "count", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "delay", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "dispatch", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "domain", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "fulfill", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "incomingRoot", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "interpreter", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isAssetOwnershipRenounced", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isRouterOwnershipRenounced", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "nonce", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "prepare", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "process", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "proposeAssetOwnershipRenunciation", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "proposeNewOwner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "proposeRouterOwnershipRenunciation", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "proposed", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "proposedTimestamp", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "reconcile", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "removeAssetId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "removeLiquidity", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "removeRelayerFees", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "removeRouter", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "renounceAssetOwnership", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "renounceOwnership", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "renounceRouterOwnership", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "renounced", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "root", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "routedTransactions", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "routedTransactionsGas", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "routerBalances", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "routerOwnershipTimestamp", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "routerRelayerFees", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setupAsset", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "tokenRegistry", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "tree", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "wrapper", data: BytesLike): Result;

  events: {
    "AssetAdded(bytes32,uint32,address,address,address)": EventFragment;
    "AssetOwnershipRenounced(bool)": EventFragment;
    "AssetOwnershipRenunciationProposed(uint256)": EventFragment;
    "AssetRemoved(bytes32,address)": EventFragment;
    "Dispatched(uint32,bytes32,address[3],uint256[3],address)": EventFragment;
    "Fulfilled(bytes32,address,address,tuple,address,address,uint256,uint256,address)": EventFragment;
    "LiquidityAdded(address,address,bytes32,uint256,address)": EventFragment;
    "LiquidityRemoved(address,address,address,uint256,address)": EventFragment;
    "OwnershipProposed(address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "Prepared(bytes32,uint256,address,tuple,address,address,uint256,uint256,uint256,address)": EventFragment;
    "Reconciled(bytes32,address)": EventFragment;
    "RouterAdded(address,address)": EventFragment;
    "RouterOwnershipRenounced(bool)": EventFragment;
    "RouterOwnershipRenunciationProposed(uint256)": EventFragment;
    "RouterRemoved(address,address)": EventFragment;
    "StableSwapAdded(bytes32,uint32,address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AssetAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AssetOwnershipRenounced"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AssetOwnershipRenunciationProposed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "AssetRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Dispatched"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Fulfilled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LiquidityAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LiquidityRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipProposed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Prepared"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Reconciled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RouterAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RouterOwnershipRenounced"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RouterOwnershipRenunciationProposed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RouterRemoved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StableSwapAdded"): EventFragment;
}

export type AssetAddedEvent = TypedEvent<
  [string, number, string, string, string],
  {
    canonicalId: string;
    domain: number;
    adoptedAsset: string;
    supportedAsset: string;
    caller: string;
  }
>;

export type AssetAddedEventFilter = TypedEventFilter<AssetAddedEvent>;

export type AssetOwnershipRenouncedEvent = TypedEvent<[boolean], { renounced: boolean }>;

export type AssetOwnershipRenouncedEventFilter = TypedEventFilter<AssetOwnershipRenouncedEvent>;

export type AssetOwnershipRenunciationProposedEvent = TypedEvent<[BigNumber], { timestamp: BigNumber }>;

export type AssetOwnershipRenunciationProposedEventFilter = TypedEventFilter<AssetOwnershipRenunciationProposedEvent>;

export type AssetRemovedEvent = TypedEvent<[string, string], { canonicalId: string; caller: string }>;

export type AssetRemovedEventFilter = TypedEventFilter<AssetRemovedEvent>;

export type DispatchedEvent = TypedEvent<
  [number, string, [string, string, string], [BigNumber, BigNumber, BigNumber], string],
  {
    destination: number;
    root: string;
    tokens: [string, string, string];
    amounts: [BigNumber, BigNumber, BigNumber];
    caller: string;
  }
>;

export type DispatchedEventFilter = TypedEventFilter<DispatchedEvent>;

export type FulfilledEvent = TypedEvent<
  [string, string, string, TransactionManager.CallParamsStructOutput, string, string, BigNumber, BigNumber, string],
  {
    transactionId: string;
    recipient: string;
    router: string;
    params: TransactionManager.CallParamsStructOutput;
    localAsset: string;
    transactingAsset: string;
    localAmount: BigNumber;
    transactingAmount: BigNumber;
    caller: string;
  }
>;

export type FulfilledEventFilter = TypedEventFilter<FulfilledEvent>;

export type LiquidityAddedEvent = TypedEvent<
  [string, string, string, BigNumber, string],
  {
    router: string;
    local: string;
    canonicalId: string;
    amount: BigNumber;
    caller: string;
  }
>;

export type LiquidityAddedEventFilter = TypedEventFilter<LiquidityAddedEvent>;

export type LiquidityRemovedEvent = TypedEvent<
  [string, string, string, BigNumber, string],
  {
    router: string;
    recipient: string;
    local: string;
    amount: BigNumber;
    caller: string;
  }
>;

export type LiquidityRemovedEventFilter = TypedEventFilter<LiquidityRemovedEvent>;

export type OwnershipProposedEvent = TypedEvent<[string], { proposedOwner: string }>;

export type OwnershipProposedEventFilter = TypedEventFilter<OwnershipProposedEvent>;

export type OwnershipTransferredEvent = TypedEvent<[string, string], { previousOwner: string; newOwner: string }>;

export type OwnershipTransferredEventFilter = TypedEventFilter<OwnershipTransferredEvent>;

export type PreparedEvent = TypedEvent<
  [
    string,
    BigNumber,
    string,
    TransactionManager.CallParamsStructOutput,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
  ],
  {
    transactionId: string;
    idx: BigNumber;
    recipient: string;
    params: TransactionManager.CallParamsStructOutput;
    transactingAsset: string;
    localAsset: string;
    transactingAmount: BigNumber;
    localAmount: BigNumber;
    nonce: BigNumber;
    caller: string;
  }
>;

export type PreparedEventFilter = TypedEventFilter<PreparedEvent>;

export type ReconciledEvent = TypedEvent<[string, string], { root: string; caller: string }>;

export type ReconciledEventFilter = TypedEventFilter<ReconciledEvent>;

export type RouterAddedEvent = TypedEvent<[string, string], { router: string; caller: string }>;

export type RouterAddedEventFilter = TypedEventFilter<RouterAddedEvent>;

export type RouterOwnershipRenouncedEvent = TypedEvent<[boolean], { renounced: boolean }>;

export type RouterOwnershipRenouncedEventFilter = TypedEventFilter<RouterOwnershipRenouncedEvent>;

export type RouterOwnershipRenunciationProposedEvent = TypedEvent<[BigNumber], { timestamp: BigNumber }>;

export type RouterOwnershipRenunciationProposedEventFilter = TypedEventFilter<RouterOwnershipRenunciationProposedEvent>;

export type RouterRemovedEvent = TypedEvent<[string, string], { router: string; caller: string }>;

export type RouterRemovedEventFilter = TypedEventFilter<RouterRemovedEvent>;

export type StableSwapAddedEvent = TypedEvent<
  [string, number, string, string],
  { canonicalId: string; domain: number; swapPool: string; caller: string }
>;

export type StableSwapAddedEventFilter = TypedEventFilter<StableSwapAddedEvent>;

export interface TransactionManager extends BaseContract {
  contractName: "TransactionManager";
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: TransactionManagerInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    acceptProposedOwner(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    addLiquidity(
      amount: BigNumberish,
      local: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    addLiquidityFor(
      amount: BigNumberish,
      local: string,
      router: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    addRelayerFees(
      router: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    addRouter(
      router: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    addStableSwapPool(
      canonical: BridgeMessage.TokenIdStruct,
      stableSwapPool: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    adoptedToCanonical(
      arg0: string,
      overrides?: CallOverrides,
    ): Promise<[number, string] & { domain: number; id: string }>;

    adoptedToLocalPools(arg0: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    approvedAssets(arg0: BytesLike, overrides?: CallOverrides): Promise<[boolean]>;

    approvedRouters(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;

    assetOwnershipTimestamp(overrides?: CallOverrides): Promise<[BigNumber]>;

    batchAmounts(arg0: BigNumberish, arg1: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;

    batchAssets(arg0: BigNumberish, arg1: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    bridgeRouter(overrides?: CallOverrides): Promise<[string]>;

    canonicalToAdopted(arg0: BytesLike, overrides?: CallOverrides): Promise<[string]>;

    count(overrides?: CallOverrides): Promise<[BigNumber]>;

    delay(overrides?: CallOverrides): Promise<[BigNumber]>;

    dispatch(
      _destination: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    domain(overrides?: CallOverrides): Promise<[BigNumber]>;

    fulfill(
      _args: TransactionManager.FulfillArgsStruct,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    initialize(
      _domain: BigNumberish,
      _bridgeRouter: string,
      _tokenRegistry: string,
      _wrappedNative: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    interpreter(overrides?: CallOverrides): Promise<[string]>;

    isAssetOwnershipRenounced(overrides?: CallOverrides): Promise<[boolean]>;

    isRouterOwnershipRenounced(overrides?: CallOverrides): Promise<[boolean]>;

    nonce(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    prepare(
      _args: TransactionManager.PrepareArgsStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    process(
      _transactionId: BytesLike,
      _amount: BigNumberish,
      _local: string,
      _index: BigNumberish,
      _proof: BytesLike[],
      _params: TransactionManager.CallParamsStruct,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    proposeAssetOwnershipRenunciation(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    proposeNewOwner(
      newlyProposed: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    proposeRouterOwnershipRenunciation(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    proposed(overrides?: CallOverrides): Promise<[string]>;

    proposedTimestamp(overrides?: CallOverrides): Promise<[BigNumber]>;

    reconcile(
      _incomingRoot: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    removeAssetId(
      canonicalId: BytesLike,
      adoptedAssetId: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    removeLiquidity(
      amount: BigNumberish,
      local: string,
      recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    removeRelayerFees(
      amount: BigNumberish,
      recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    removeRouter(
      router: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    renounceAssetOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    renounceRouterOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

    renounced(overrides?: CallOverrides): Promise<[boolean]>;

    root(overrides?: CallOverrides): Promise<[string]>;

    routedTransactions(
      arg0: BytesLike,
      overrides?: CallOverrides,
    ): Promise<
      [string, BigNumber, string] & {
        router: string;
        amount: BigNumber;
        externalHash: string;
      }
    >;

    routedTransactionsGas(
      arg0: BytesLike,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { gasUsed: BigNumber; gasPrice: BigNumber }>;

    routerBalances(arg0: string, arg1: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    routerOwnershipTimestamp(overrides?: CallOverrides): Promise<[BigNumber]>;

    routerRelayerFees(arg0: string, overrides?: CallOverrides): Promise<[BigNumber]>;

    setupAsset(
      canonical: BridgeMessage.TokenIdStruct,
      adoptedAssetId: string,
      stableSwapPool: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<ContractTransaction>;

    tokenRegistry(overrides?: CallOverrides): Promise<[string]>;

    tree(overrides?: CallOverrides): Promise<[BigNumber] & { count: BigNumber }>;

    wrapper(overrides?: CallOverrides): Promise<[string]>;
  };

  acceptProposedOwner(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  addLiquidity(
    amount: BigNumberish,
    local: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  addLiquidityFor(
    amount: BigNumberish,
    local: string,
    router: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  addRelayerFees(
    router: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  addRouter(router: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  addStableSwapPool(
    canonical: BridgeMessage.TokenIdStruct,
    stableSwapPool: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  adoptedToCanonical(
    arg0: string,
    overrides?: CallOverrides,
  ): Promise<[number, string] & { domain: number; id: string }>;

  adoptedToLocalPools(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

  approvedAssets(arg0: BytesLike, overrides?: CallOverrides): Promise<boolean>;

  approvedRouters(arg0: string, overrides?: CallOverrides): Promise<boolean>;

  assetOwnershipTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

  batchAmounts(arg0: BigNumberish, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

  batchAssets(arg0: BigNumberish, arg1: BigNumberish, overrides?: CallOverrides): Promise<string>;

  bridgeRouter(overrides?: CallOverrides): Promise<string>;

  canonicalToAdopted(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

  count(overrides?: CallOverrides): Promise<BigNumber>;

  delay(overrides?: CallOverrides): Promise<BigNumber>;

  dispatch(
    _destination: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  domain(overrides?: CallOverrides): Promise<BigNumber>;

  fulfill(
    _args: TransactionManager.FulfillArgsStruct,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  initialize(
    _domain: BigNumberish,
    _bridgeRouter: string,
    _tokenRegistry: string,
    _wrappedNative: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  interpreter(overrides?: CallOverrides): Promise<string>;

  isAssetOwnershipRenounced(overrides?: CallOverrides): Promise<boolean>;

  isRouterOwnershipRenounced(overrides?: CallOverrides): Promise<boolean>;

  nonce(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  prepare(
    _args: TransactionManager.PrepareArgsStruct,
    overrides?: PayableOverrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  process(
    _transactionId: BytesLike,
    _amount: BigNumberish,
    _local: string,
    _index: BigNumberish,
    _proof: BytesLike[],
    _params: TransactionManager.CallParamsStruct,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  proposeAssetOwnershipRenunciation(
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  proposeNewOwner(
    newlyProposed: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  proposeRouterOwnershipRenunciation(
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  proposed(overrides?: CallOverrides): Promise<string>;

  proposedTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

  reconcile(
    _incomingRoot: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  removeAssetId(
    canonicalId: BytesLike,
    adoptedAssetId: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  removeLiquidity(
    amount: BigNumberish,
    local: string,
    recipient: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  removeRelayerFees(
    amount: BigNumberish,
    recipient: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  removeRouter(
    router: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  renounceAssetOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  renounceOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  renounceRouterOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<ContractTransaction>;

  renounced(overrides?: CallOverrides): Promise<boolean>;

  root(overrides?: CallOverrides): Promise<string>;

  routedTransactions(
    arg0: BytesLike,
    overrides?: CallOverrides,
  ): Promise<
    [string, BigNumber, string] & {
      router: string;
      amount: BigNumber;
      externalHash: string;
    }
  >;

  routedTransactionsGas(
    arg0: BytesLike,
    overrides?: CallOverrides,
  ): Promise<[BigNumber, BigNumber] & { gasUsed: BigNumber; gasPrice: BigNumber }>;

  routerBalances(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

  routerOwnershipTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

  routerRelayerFees(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

  setupAsset(
    canonical: BridgeMessage.TokenIdStruct,
    adoptedAssetId: string,
    stableSwapPool: string,
    overrides?: Overrides & { from?: string | Promise<string> },
  ): Promise<ContractTransaction>;

  tokenRegistry(overrides?: CallOverrides): Promise<string>;

  tree(overrides?: CallOverrides): Promise<BigNumber>;

  wrapper(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    acceptProposedOwner(overrides?: CallOverrides): Promise<void>;

    addLiquidity(amount: BigNumberish, local: string, overrides?: CallOverrides): Promise<void>;

    addLiquidityFor(amount: BigNumberish, local: string, router: string, overrides?: CallOverrides): Promise<void>;

    addRelayerFees(router: string, overrides?: CallOverrides): Promise<void>;

    addRouter(router: string, overrides?: CallOverrides): Promise<void>;

    addStableSwapPool(
      canonical: BridgeMessage.TokenIdStruct,
      stableSwapPool: string,
      overrides?: CallOverrides,
    ): Promise<void>;

    adoptedToCanonical(
      arg0: string,
      overrides?: CallOverrides,
    ): Promise<[number, string] & { domain: number; id: string }>;

    adoptedToLocalPools(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

    approvedAssets(arg0: BytesLike, overrides?: CallOverrides): Promise<boolean>;

    approvedRouters(arg0: string, overrides?: CallOverrides): Promise<boolean>;

    assetOwnershipTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    batchAmounts(arg0: BigNumberish, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    batchAssets(arg0: BigNumberish, arg1: BigNumberish, overrides?: CallOverrides): Promise<string>;

    bridgeRouter(overrides?: CallOverrides): Promise<string>;

    canonicalToAdopted(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

    count(overrides?: CallOverrides): Promise<BigNumber>;

    delay(overrides?: CallOverrides): Promise<BigNumber>;

    dispatch(_destination: BigNumberish, overrides?: CallOverrides): Promise<void>;

    domain(overrides?: CallOverrides): Promise<BigNumber>;

    fulfill(_args: TransactionManager.FulfillArgsStruct, overrides?: CallOverrides): Promise<string>;

    initialize(
      _domain: BigNumberish,
      _bridgeRouter: string,
      _tokenRegistry: string,
      _wrappedNative: string,
      overrides?: CallOverrides,
    ): Promise<void>;

    interpreter(overrides?: CallOverrides): Promise<string>;

    isAssetOwnershipRenounced(overrides?: CallOverrides): Promise<boolean>;

    isRouterOwnershipRenounced(overrides?: CallOverrides): Promise<boolean>;

    nonce(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    prepare(_args: TransactionManager.PrepareArgsStruct, overrides?: CallOverrides): Promise<string>;

    process(
      _transactionId: BytesLike,
      _amount: BigNumberish,
      _local: string,
      _index: BigNumberish,
      _proof: BytesLike[],
      _params: TransactionManager.CallParamsStruct,
      overrides?: CallOverrides,
    ): Promise<void>;

    proposeAssetOwnershipRenunciation(overrides?: CallOverrides): Promise<void>;

    proposeNewOwner(newlyProposed: string, overrides?: CallOverrides): Promise<void>;

    proposeRouterOwnershipRenunciation(overrides?: CallOverrides): Promise<void>;

    proposed(overrides?: CallOverrides): Promise<string>;

    proposedTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    reconcile(_incomingRoot: BytesLike, overrides?: CallOverrides): Promise<void>;

    removeAssetId(canonicalId: BytesLike, adoptedAssetId: string, overrides?: CallOverrides): Promise<void>;

    removeLiquidity(amount: BigNumberish, local: string, recipient: string, overrides?: CallOverrides): Promise<void>;

    removeRelayerFees(amount: BigNumberish, recipient: string, overrides?: CallOverrides): Promise<void>;

    removeRouter(router: string, overrides?: CallOverrides): Promise<void>;

    renounceAssetOwnership(overrides?: CallOverrides): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    renounceRouterOwnership(overrides?: CallOverrides): Promise<void>;

    renounced(overrides?: CallOverrides): Promise<boolean>;

    root(overrides?: CallOverrides): Promise<string>;

    routedTransactions(
      arg0: BytesLike,
      overrides?: CallOverrides,
    ): Promise<
      [string, BigNumber, string] & {
        router: string;
        amount: BigNumber;
        externalHash: string;
      }
    >;

    routedTransactionsGas(
      arg0: BytesLike,
      overrides?: CallOverrides,
    ): Promise<[BigNumber, BigNumber] & { gasUsed: BigNumber; gasPrice: BigNumber }>;

    routerBalances(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

    routerOwnershipTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    routerRelayerFees(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    setupAsset(
      canonical: BridgeMessage.TokenIdStruct,
      adoptedAssetId: string,
      stableSwapPool: string,
      overrides?: CallOverrides,
    ): Promise<void>;

    tokenRegistry(overrides?: CallOverrides): Promise<string>;

    tree(overrides?: CallOverrides): Promise<BigNumber>;

    wrapper(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "AssetAdded(bytes32,uint32,address,address,address)"(
      canonicalId?: null,
      domain?: null,
      adoptedAsset?: null,
      supportedAsset?: null,
      caller?: null,
    ): AssetAddedEventFilter;
    AssetAdded(
      canonicalId?: null,
      domain?: null,
      adoptedAsset?: null,
      supportedAsset?: null,
      caller?: null,
    ): AssetAddedEventFilter;

    "AssetOwnershipRenounced(bool)"(renounced?: null): AssetOwnershipRenouncedEventFilter;
    AssetOwnershipRenounced(renounced?: null): AssetOwnershipRenouncedEventFilter;

    "AssetOwnershipRenunciationProposed(uint256)"(timestamp?: null): AssetOwnershipRenunciationProposedEventFilter;
    AssetOwnershipRenunciationProposed(timestamp?: null): AssetOwnershipRenunciationProposedEventFilter;

    "AssetRemoved(bytes32,address)"(canonicalId?: null, caller?: null): AssetRemovedEventFilter;
    AssetRemoved(canonicalId?: null, caller?: null): AssetRemovedEventFilter;

    "Dispatched(uint32,bytes32,address[3],uint256[3],address)"(
      destination?: null,
      root?: null,
      tokens?: null,
      amounts?: null,
      caller?: null,
    ): DispatchedEventFilter;
    Dispatched(destination?: null, root?: null, tokens?: null, amounts?: null, caller?: null): DispatchedEventFilter;

    "Fulfilled(bytes32,address,address,tuple,address,address,uint256,uint256,address)"(
      transactionId?: BytesLike | null,
      recipient?: string | null,
      router?: string | null,
      params?: null,
      localAsset?: null,
      transactingAsset?: null,
      localAmount?: null,
      transactingAmount?: null,
      caller?: null,
    ): FulfilledEventFilter;
    Fulfilled(
      transactionId?: BytesLike | null,
      recipient?: string | null,
      router?: string | null,
      params?: null,
      localAsset?: null,
      transactingAsset?: null,
      localAmount?: null,
      transactingAmount?: null,
      caller?: null,
    ): FulfilledEventFilter;

    "LiquidityAdded(address,address,bytes32,uint256,address)"(
      router?: null,
      local?: null,
      canonicalId?: null,
      amount?: null,
      caller?: null,
    ): LiquidityAddedEventFilter;
    LiquidityAdded(
      router?: null,
      local?: null,
      canonicalId?: null,
      amount?: null,
      caller?: null,
    ): LiquidityAddedEventFilter;

    "LiquidityRemoved(address,address,address,uint256,address)"(
      router?: string | null,
      recipient?: null,
      local?: null,
      amount?: null,
      caller?: null,
    ): LiquidityRemovedEventFilter;
    LiquidityRemoved(
      router?: string | null,
      recipient?: null,
      local?: null,
      amount?: null,
      caller?: null,
    ): LiquidityRemovedEventFilter;

    "OwnershipProposed(address)"(proposedOwner?: string | null): OwnershipProposedEventFilter;
    OwnershipProposed(proposedOwner?: string | null): OwnershipProposedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null,
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(previousOwner?: string | null, newOwner?: string | null): OwnershipTransferredEventFilter;

    "Prepared(bytes32,uint256,address,tuple,address,address,uint256,uint256,uint256,address)"(
      transactionId?: BytesLike | null,
      idx?: BigNumberish | null,
      recipient?: string | null,
      params?: null,
      transactingAsset?: null,
      localAsset?: null,
      transactingAmount?: null,
      localAmount?: null,
      nonce?: null,
      caller?: null,
    ): PreparedEventFilter;
    Prepared(
      transactionId?: BytesLike | null,
      idx?: BigNumberish | null,
      recipient?: string | null,
      params?: null,
      transactingAsset?: null,
      localAsset?: null,
      transactingAmount?: null,
      localAmount?: null,
      nonce?: null,
      caller?: null,
    ): PreparedEventFilter;

    "Reconciled(bytes32,address)"(root?: null, caller?: null): ReconciledEventFilter;
    Reconciled(root?: null, caller?: null): ReconciledEventFilter;

    "RouterAdded(address,address)"(router?: null, caller?: null): RouterAddedEventFilter;
    RouterAdded(router?: null, caller?: null): RouterAddedEventFilter;

    "RouterOwnershipRenounced(bool)"(renounced?: null): RouterOwnershipRenouncedEventFilter;
    RouterOwnershipRenounced(renounced?: null): RouterOwnershipRenouncedEventFilter;

    "RouterOwnershipRenunciationProposed(uint256)"(timestamp?: null): RouterOwnershipRenunciationProposedEventFilter;
    RouterOwnershipRenunciationProposed(timestamp?: null): RouterOwnershipRenunciationProposedEventFilter;

    "RouterRemoved(address,address)"(router?: null, caller?: null): RouterRemovedEventFilter;
    RouterRemoved(router?: null, caller?: null): RouterRemovedEventFilter;

    "StableSwapAdded(bytes32,uint32,address,address)"(
      canonicalId?: null,
      domain?: null,
      swapPool?: null,
      caller?: null,
    ): StableSwapAddedEventFilter;
    StableSwapAdded(canonicalId?: null, domain?: null, swapPool?: null, caller?: null): StableSwapAddedEventFilter;
  };

  estimateGas: {
    acceptProposedOwner(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    addLiquidity(
      amount: BigNumberish,
      local: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    addLiquidityFor(
      amount: BigNumberish,
      local: string,
      router: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    addRelayerFees(
      router: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    addRouter(router: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    addStableSwapPool(
      canonical: BridgeMessage.TokenIdStruct,
      stableSwapPool: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    adoptedToCanonical(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    adoptedToLocalPools(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    approvedAssets(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    approvedRouters(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    assetOwnershipTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    batchAmounts(arg0: BigNumberish, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    batchAssets(arg0: BigNumberish, arg1: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    bridgeRouter(overrides?: CallOverrides): Promise<BigNumber>;

    canonicalToAdopted(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    count(overrides?: CallOverrides): Promise<BigNumber>;

    delay(overrides?: CallOverrides): Promise<BigNumber>;

    dispatch(
      _destination: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    domain(overrides?: CallOverrides): Promise<BigNumber>;

    fulfill(
      _args: TransactionManager.FulfillArgsStruct,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    initialize(
      _domain: BigNumberish,
      _bridgeRouter: string,
      _tokenRegistry: string,
      _wrappedNative: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    interpreter(overrides?: CallOverrides): Promise<BigNumber>;

    isAssetOwnershipRenounced(overrides?: CallOverrides): Promise<BigNumber>;

    isRouterOwnershipRenounced(overrides?: CallOverrides): Promise<BigNumber>;

    nonce(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    prepare(
      _args: TransactionManager.PrepareArgsStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    process(
      _transactionId: BytesLike,
      _amount: BigNumberish,
      _local: string,
      _index: BigNumberish,
      _proof: BytesLike[],
      _params: TransactionManager.CallParamsStruct,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    proposeAssetOwnershipRenunciation(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    proposeNewOwner(
      newlyProposed: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    proposeRouterOwnershipRenunciation(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    proposed(overrides?: CallOverrides): Promise<BigNumber>;

    proposedTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    reconcile(
      _incomingRoot: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    removeAssetId(
      canonicalId: BytesLike,
      adoptedAssetId: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    removeLiquidity(
      amount: BigNumberish,
      local: string,
      recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    removeRelayerFees(
      amount: BigNumberish,
      recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    removeRouter(router: string, overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    renounceAssetOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    renounceOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    renounceRouterOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<BigNumber>;

    renounced(overrides?: CallOverrides): Promise<BigNumber>;

    root(overrides?: CallOverrides): Promise<BigNumber>;

    routedTransactions(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    routedTransactionsGas(arg0: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    routerBalances(arg0: string, arg1: string, overrides?: CallOverrides): Promise<BigNumber>;

    routerOwnershipTimestamp(overrides?: CallOverrides): Promise<BigNumber>;

    routerRelayerFees(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;

    setupAsset(
      canonical: BridgeMessage.TokenIdStruct,
      adoptedAssetId: string,
      stableSwapPool: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<BigNumber>;

    tokenRegistry(overrides?: CallOverrides): Promise<BigNumber>;

    tree(overrides?: CallOverrides): Promise<BigNumber>;

    wrapper(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    acceptProposedOwner(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    addLiquidity(
      amount: BigNumberish,
      local: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    addLiquidityFor(
      amount: BigNumberish,
      local: string,
      router: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    addRelayerFees(
      router: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    addRouter(
      router: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    addStableSwapPool(
      canonical: BridgeMessage.TokenIdStruct,
      stableSwapPool: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    adoptedToCanonical(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    adoptedToLocalPools(arg0: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    approvedAssets(arg0: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    approvedRouters(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    assetOwnershipTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    batchAmounts(arg0: BigNumberish, arg1: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    batchAssets(arg0: BigNumberish, arg1: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    bridgeRouter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    canonicalToAdopted(arg0: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    count(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    delay(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    dispatch(
      _destination: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    domain(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    fulfill(
      _args: TransactionManager.FulfillArgsStruct,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    initialize(
      _domain: BigNumberish,
      _bridgeRouter: string,
      _tokenRegistry: string,
      _wrappedNative: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    interpreter(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isAssetOwnershipRenounced(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    isRouterOwnershipRenounced(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nonce(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    prepare(
      _args: TransactionManager.PrepareArgsStruct,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    process(
      _transactionId: BytesLike,
      _amount: BigNumberish,
      _local: string,
      _index: BigNumberish,
      _proof: BytesLike[],
      _params: TransactionManager.CallParamsStruct,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    proposeAssetOwnershipRenunciation(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    proposeNewOwner(
      newlyProposed: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    proposeRouterOwnershipRenunciation(
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    proposed(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposedTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    reconcile(
      _incomingRoot: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    removeAssetId(
      canonicalId: BytesLike,
      adoptedAssetId: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    removeLiquidity(
      amount: BigNumberish,
      local: string,
      recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    removeRelayerFees(
      amount: BigNumberish,
      recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    removeRouter(
      router: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    renounceAssetOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    renounceOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    renounceRouterOwnership(overrides?: Overrides & { from?: string | Promise<string> }): Promise<PopulatedTransaction>;

    renounced(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    root(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    routedTransactions(arg0: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    routedTransactionsGas(arg0: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    routerBalances(arg0: string, arg1: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    routerOwnershipTimestamp(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    routerRelayerFees(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setupAsset(
      canonical: BridgeMessage.TokenIdStruct,
      adoptedAssetId: string,
      stableSwapPool: string,
      overrides?: Overrides & { from?: string | Promise<string> },
    ): Promise<PopulatedTransaction>;

    tokenRegistry(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tree(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    wrapper(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
